
//wraper for http client request, and http server (express.js) init .


var CONST = require("../utils/const").LOG;
var log_manager = require("../log/log");

_err = log_manager.log.bind(log_manager,CONST.ERR_LOG);

var http = require("http");
var https = require("https");
var parse = require("url").parse;

//default is 5
http.globalAgent.maxSockets = 1024; 
https.globalAgent.maxSockets = 1024; 

//init http server from config
/*
  config is such as :
  
  {
   
   s1 : {url : str, alias : [...], port : num, default : 1},
   
   ...
   
  }
*/
exports.init_http = function(conf){
  
  var ret = {};
  
  //the bodyParser module will cause warning,just ignore it.
  var old_fn = console.warn;
  console.warn = function(){};
  
  var express = require("express");
  
  //default 404
  function notfound(req,res){
    res.status(404);
    res.send("<html><head><title>404</title></head><body bgcolor=\"white\" text=\"black\"><center><h1>Page Not Found!</h1></center></body></html>");
  }
  
  //default err
  function handle_err(err, req, res, next){
    
    _err("http meet err %j, close client socket.",err);
    
    res.socket.destroy();
  }  
  
  //our body parser wrapper
  var _urlencoded = express.urlencoded();
  var _multipart = express.multipart();
  var _json = express.json({strict:false});

  function body_parser(req, res, next) {
    _json(req, res, function(err){
      if (err)
	  {
		//maybe body is uri encode
		if(err.body)
		{
		  try {
			req.body = JSON.parse(decodeURIComponent(err.body));
		  } catch (newerr){
			newerr.body = err.body;
			newerr.status = 400;
			return next(newerr);
		  }
		  return next();
		}
		else
			return next(err);  
	  }
      _urlencoded(req, res, function(err){
        if (err) return next(err);
        _multipart(req, res, next);
      });
    });
  }
  
  //use vhost for the same port server
  var port_map = {};
  
  //xml body parser
  var xmlbody = null;
  try
  {
    xmlbody = require("express-xml-bodyparser");
  }
  catch(e){
    _err("http module is not found : express-xml-bodyparser !");
  }  
  
  for(var key in conf)
  {
    var server = conf[key];
    
    var s_app = express();
    
    //we need bodyParser -- include multipart,urlencoded,json
    s_app.use(body_parser);
    
    //we also need xml body parser
    if(xmlbody){
      s_app.use(xmlbody({explicitArray:false,normalize:false,trim:false}));
    }
    
    ret[key] = s_app;
    
    port_map[server.port] = port_map[server.port] || [];
    
    port_map[server.port].push({"url" : server.url, "app" : s_app, "alias" : server.alias, "default" : server["default"]});
  }

  //start listen port
  for(var port in port_map)
  {
    var arr = port_map[port];
    var _app = express();
    
    var _default = null;
    
    for(var i = 0; i < arr.length; i++)
    {
      _app.use(express.vhost(arr[i].url, arr[i].app));
      
      //check alias - use the same app
      if(arr[i].alias instanceof Array)
      {
        for(var j = 0; j < arr[i].alias.length; j++)
        {
          _app.use(express.vhost(arr[i].alias[j], arr[i].app)); 
        }
      }
      
      if(arr[i]["default"] == 1)
      {
        _default = arr[i].app;
      }
    }
    
    if(_default)
    {
      _app.use(express.vhost("*", _default));
    }
    
    //set default 404
    _app.use(notfound);
    
    //set default error handler
    _app.use(handle_err);
    
    _app.listen(port);
  }
  
  //restore
  console.warn = old_fn;
  
  return ret;
};


//------------------ for http get , post -------------------//

/* callback like this:

fn = function(err,data,res){
  if(err)
  {
    //error
  }
  else
  {
    console.log(data);  
  }
}

*/
//options.useBuffer is for our internal use, mean the response should use buffer or string(default).
exports.get = function(url,fn){

  var options;

  //url,options,fn
  if(typeof fn === "object"){
    options = fn;
    fn = arguments[2];
  }
  else
  {
    options = {};
  }
  
  options.method = "GET";
  var req = request(url,options,fn);
  if(req)
  {
    req.end();
  }
};

exports.post = function(url,data,fn){
  
  var options = {};
  
  //url,options,data,fn
  if(arguments.length === 4){
    options = data;
    data = fn;
    fn = arguments[3];
  }
  else if(arguments.length === 3){
    if(typeof fn !== "function"){
      //url,options,data
      options = data;
      data = fn;
      fn = undefined;
    }
  }
  
  //check data
  var s_data;  								//if string ,must use utf8
  options.headers = options.headers || {};
  if(typeof data === "object"){
	  
	if(Buffer.isBuffer(data))
	{
		s_data = data;
		//set header
		options.headers["Content-Type"] = "application/octet-stream";
	}
	else
	{
		//json
		try{
		  s_data = JSON.stringify(data);
		  
		  //set header
		  options.headers["Content-Type"] = "application/json; charset=UTF-8";
		}catch(e){
		  s_data = "";
		}		
	}
  }
  else if(typeof data === "string"){
    
    if(/^\s*</.test(data))
    {
      options.headers["Content-Type"] = "text/xml; charset=UTF-8";  
    }
    else
    {
      options.headers["Content-Type"] = "application/x-www-form-urlencoded; charset=UTF-8";
    }
    
    s_data = data;
  }
  else
  {
    s_data = "";
  }
  
  //we use "Content-length" not "chunkedEncoding" ,which some server not support.
  options.headers["Content-Length"] = Buffer.byteLength(s_data);
  
  options.method = "POST";
  
  var req = request(url,options,fn);
  if(req)
  {
    req.end(s_data,"utf8");
  }
};


//internal function
function request(url,options,cb){
  
  //check have protocol
  if(!/^.*\:\/\//.test(url)){
    url = "http://" + url;
  }
  
  var http_fn;
  var ret = parse(url);
  if(ret.protocol == "http:"){
    
    http_fn = http.request;
    options.port = ret.port === null ? 80 : ret.port;
  }
  else if(ret.protocol == "https:"){
    
    http_fn = https.request;
    options.port = ret.port === null ? 443 : ret.port;
  }
  else
  {
    if(typeof cb === "function"){
      //callback when next tick
      process.nextTick(function(){
        //we need catch app level error.
        try
        {
          cb(ret.protocol + " is not support.");
        }catch(e)
        {
          _err(e);
        }
      });
    }
    return null;
  }
  
  options.hostname = ret.hostname;
  options.path = ret.path;

  //check response type
  var res_isbuffer = options.useBuffer != undefined ? !!options.useBuffer : false;
  delete options.useBuffer;
  
  var req = http_fn(options, function(res){
    
	if(res_isbuffer)
	{
		var chunk_arr = [];
		var chunk_len = 0;
		
		//store data
		res.on("data", function (chunk) {
		  chunk_len += chunk.length;
		  chunk_arr.push(chunk);
		});
		//we do not need catch close, end will be called when close.
		res.on("end", function () {      
		  if(typeof cb === "function"){
			
			var resbuf = new Buffer(chunk_len);
			var restail = 0;
			for(var i = 0; i < chunk_arr.length; i++)
			{
				chunk_arr[i].copy(resbuf,restail);
				restail += chunk_arr[i].length;
			}	
			//we need catch app level error.
			try
			{
			  cb(null,resbuf,res);
			}catch(e)
			{
			  _err(e);
			}
		  }
		});		
	}
	else
	{
		res.setEncoding("utf8");
		var response = "";
		
		//store data
		res.on("data", function (chunk) {
		  response += chunk;
		});
		//we do not need catch close, end will be called when close.
		res.on("end", function () {      
		  if(typeof cb === "function"){
			//we need catch app level error.
			try
			{
			  cb(null,response,res);
			}catch(e)
			{
			  _err(e);
			}
		  }
		});			
	}
  });
  
  //this will be called when socket cloesed before any response data, and all socket err will cause this event.
  req.on("error", function(err) {
    
    if(typeof cb === "function"){
      //we need catch app level error.
      try
      {
        cb(err);
      }catch(e)
      {
        _err(e);
      }
    }    
  });
  
  return req;
}

