//test success in db driver: "1.3.23" , "1.4.29"
//it may be compatible with db driver 1.x


//since the db use connection pool, which may cause the same collection commands disorder.
//hook db, to ensure that we use the same connection for the same collection


function db_hook(db) {
   
   this.db = db;
   
   //this.connections;           //store the connections used for collections  
   //this.cur_index;             //store current connection id in pool
   //this.cur_collection;        //store current collection name
   
   
   //hook connection when pool connected
   var self = this;
   db.on("open",function(){
      self.hook_dbconnection();
   });

   db.on("reconnect",function(){
      self.hook_dbconnection(); 
   });
   
   self.hook_dbcommand();
}

//hook the command to catch the collection name
db_hook.prototype.hook_dbcommand = function(){
  
   var self = this;
   
   var db = self.db;
  
   //hook query
   var old_executeQueryCommand = db._executeQueryCommand;
   db._executeQueryCommand = function(cmd,op){
      
      var cur_collection = cmd.collectionName;
      
      //we need handle db cmd function specially , since it as DbCommand.SYSTEM_COMMAND_COLLECTION = "$cmd"
      var index = cur_collection.lastIndexOf("$cmd");
      if (index > -1) {
         cur_collection = cur_collection.slice(0,index);
		 if(cmd.query)
		 {
			 //count method
			 if(cmd.query.count)
			 {
				 cur_collection += cmd.query.count;
			 }
             //drop method
             else if(cmd.query.drop)
             {
                 cur_collection += cmd.query.drop;
             }
			 //distinct method
			 else if(cmd.query.distinct)
			 {
				 cur_collection += cmd.query.distinct;
			 }
			 //mapreduce method
			 else if(cmd.query.mapreduce)
			 {
				 cur_collection += cmd.query.mapreduce;
			 }
		 }
      }
	  else
	  {
		  //check is "exist"
		  index = cur_collection.lastIndexOf(".system.namespaces");
		  if(index > -1)
		  {
			if(cmd.query && cmd.query.name)
			{
				cur_collection = cmd.query.name;
			}
		  }
	  }
      
      //set current command collection name
      self.cur_collection = cur_collection;
      
      //for has a connection,set it to null,do not use it
      if (op && op.connection) {
         op.connection = null;
      }
      
      old_executeQueryCommand.apply(this,arguments);
   };
   
   //hook insert
   var old_executeInsertCommand = db._executeInsertCommand;
   db._executeInsertCommand = function(cmd,op){
      
      //set current command collection name
      self.cur_collection = cmd.collectionName;
      
      //for has a connection,set it to null,do not use it
      if (op && op.connection) {
         op.connection = null;
      }
      
      old_executeInsertCommand.apply(this,arguments);      
   };
   
   
   //in db.js
   //Db.prototype._executeUpdateCommand = Db.prototype._executeInsertCommand;
   //Db.prototype._executeRemoveCommand = Db.prototype._executeInsertCommand;
   //so we need reset.
   db._executeUpdateCommand = db._executeInsertCommand;
   db._executeRemoveCommand = db._executeInsertCommand;        
   
};

//hook the server.connectionPool.checkoutConnection
db_hook.prototype.hook_dbconnection = function(){
   
   this.connections = {};
   this.cur_index = 0;
   
   var self = this;
   var server = this.db.serverConfig;

   server.connectionPool.checkoutConnection = function() {
      
      if (!this.isConnected()) {
         return null;
      }
      
      if (self.cur_collection === undefined) {
         
         //since base.js : NonExecutedOperationStore.prototype.execute_queries
         //              : NonExecutedOperationStore.prototype.execute_writes
         //and   cursor.js : Cursor.prototype.nextObject
         //will call checkoutConnection before Command, so just return a connection for spoof
         
         var openConnections = this.getAllConnections();
         return openConnections[0];
      }
      
      var connection = self.connections[self.cur_collection];
      
      //assign a connection to collection
      if (!connection) {
         
         var connections = this.getAllConnections();
         
         if (self.cur_index >= connections.length) {
            self.cur_index = 0;
         }
         connection = connections[self.cur_index++];
         
         self.connections[self.cur_collection] = connection;
      }
      
      //reset collection name
      self.cur_collection = undefined;
      
      return connection;
   };

};

module.exports = db_hook;

