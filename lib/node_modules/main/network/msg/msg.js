
//net msg , the format is : head + crypto body

var CONST = require("../../utils/const").NET;

//store all files
var head_file = {};
head_file[CONST.HEAD_JSON] = "./head/hjson";
head_file[CONST.HEAD_BINARY] = "./head/hbinary";		//speed fast than hjson, and use less space.

var body_file = {};
body_file[CONST.BODY_JSON] = "./body/json";			//speed fast than bson
body_file[CONST.BODY_BSON] = "./body/bson";			//use less space than json, in mobile game, less space is important than speed.

var crypto_file = {};
crypto_file[CONST.CRYPTO_DUMMY] = "./crypto/dummy";
crypto_file[CONST.CRYPTO_AES] = "./crypto/aes";			//aes will cost 10~20 bytes than origin.


function msg(head,body,crypto){
   
   if(head === undefined || !head_file[head]){
      head = CONST.HEAD_DEFAULT;
   }
   
   if(body === undefined || !body_file[body]){
      body = CONST.BODY_DEFAULT;
   }
   
   if(crypto === undefined || !crypto_file[crypto]){
      crypto = CONST.CRYPTO_DEFAULT;
   }
   
   var t_class;
   
   t_class = require(head_file[head]);
   this.head = new t_class();

   t_class = require(body_file[body]);
   this.body = new t_class();
   
   t_class = require(crypto_file[crypto]);
   this.crypto = new t_class();
   
   
   //store body buffer
   this.body_buffer = null;
   this.body_curlen = 0;
}

msg.prototype.sethead = function(head,recvsize){
   
   if(head !== undefined && head_file[head]){
      var t_class = require(head_file[head]);
      this.head = new t_class(recvsize);
   }   
};

msg.prototype.setbody = function(body){
   
   if(body !== undefined && body_file[body]){
      var t_class = require(body_file[body]);
      this.body = new t_class();
   }   
};

msg.prototype.setcrypto = function(crypto){
  
   if(typeof crypto == "object")
   {
	   if(typeof crypto.encode == "function" && typeof crypto.decode == "function")
	   {
		   this.crypto = crypto;
	   }
   }
   else if(crypto !== undefined && crypto_file[crypto]){
      var t_class = require(crypto_file[crypto]);
      this.crypto = new t_class();
   }   
};

msg.prototype.encode = function(obj){
   
   var body = this.body.encode(obj);
   
   var crypto_body = this.crypto.encode(body);
   
   var head = this.head.encode(crypto_body);
   
   return {"head" : head, "body" : crypto_body};
};

//return {off , msg}
msg.prototype.decode = function(buffer,offset,end){
   
   try
   {
      if(this.body_buffer === null){
	 var ret = this.head.decode(buffer,offset,end);
	 
	 if(ret.len === -1)
	 {
	    //head is not complete
	    return {off:-1, msg:null};
	 }
	 else
	 {
	    this.body_buffer = new Buffer(ret.len);
	    offset = ret.off;
	 }
      }
      
      var min_len = Math.min(end - offset , this.body_buffer.length - this.body_curlen);
      buffer.copy(this.body_buffer,this.body_curlen, offset,offset + min_len);
      this.body_curlen += min_len;         
      
      //check recv all msg
      if(this.body_curlen < this.body_buffer.length)
      {
	 return {off:-1, msg:null};
      }
      
      //decode body
      var decode_buf = this.crypto.decode(this.body_buffer);
      var msg_obj = this.body.decode(decode_buf);
      
      //reset
      this.body_buffer = null;
      this.body_curlen = 0;
      
      return {off:offset+min_len, msg:msg_obj};
   }
   catch(e)
   {
      //reset
      this.body_buffer = null;
      this.body_curlen = 0;
      
      throw e;
   }
};

module.exports = msg;

