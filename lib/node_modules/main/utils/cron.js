//timer such as linux crontab

//static data
var _cron_fields = ["minute","hour","day","month","week"];
var _cron_limit = [[0,59],[0,23],[1,31],[1,12],[0,6]];      //week 0 mean sunday


var _format_err = "format str should be linux crontab ,like this : * 1,2 1-20/2 * 6";

function cron(str) {
  
  if (!(this instanceof cron)) {
    return new cron(str);
  }
  
  if (typeof str !== "string") {
    
    this.err = _format_err;
    
    return;
  }

  //parse string
  
  //remove begin and end space.
  str = str.replace(/^\s\s*|\s\s*$/g, '');
  
  //get all fields
  var fields = str.split(/\s+/);
  
  if (fields.length != 5) {
    
    this.err = _format_err;
    
    return;
  }
  
  for(var i = 0; i < fields.length; i++)
  {
    var arr = _parse(fields[i],_cron_limit[i][0],_cron_limit[i][1]);
    
    if (arr.length === 0) {
      
      this.err = _format_err;
      
      return;
    }
    else
    {
      this[_cron_fields[i]] = arr;
    }
  }
  
  //seconds allways be 0
  this.second = [0];
  
  //js date , month is from 0 to 11 so just sub 1
  this.month.forEach(function(e,i,a){
    a[i]--;  
  });
}

//get parse err
cron.prototype.geterr = function(){
  return this.err;
};

//get the next trigger time from t , we use msec as arg and ret.
cron.prototype.getnext = function(t){
  
  //check format is valid
  if (this.err) {
    return -1;
  }
  
  var ms = parseInt(t,10);
  if (isNaN(ms)) {
    return -1;
  }
  
  //add 1 sec to avoid t is just the trigger time
  ms+=1000;
  
  var nt = new Date(ms);
  
  var orig_year = nt.getFullYear();
  while(true)
  {
    var nt_year = nt.getFullYear();
    if (nt_year - orig_year > 1) {
      
      //one year has no day to match.
      //this may be cause by day and week field has some problem.
      
      //console.log("over one year can not match,ensure your days!");
      
      return -1;
    }
    
    //check month
    var now = nt.getMonth();
    
    var next = _getnext(now,this.month);
    next = this.month[next];
    
    if (now == next) {
      //match now,do nothing
    }
    else
    {
      if (now > next) {
        //need set year
        nt.setYear(nt.getFullYear() + 1);
      }
      //the time is not reach,so reset all to begin
      nt.setMonth(next);
      nt.setDate(1);
      nt.setHours(0);
      nt.setMinutes(0);
      nt.setSeconds(0);
    }
    
    
    //check day
    now = nt.getDate();
    var dindex = _getnext(now,this.day); 
    next = this.day[dindex];
    
    var now_week = nt.getDay();
    var next_week = _getnext(now_week,this.week);
    next_week = this.week[next_week];
    if (now == next && now_week == next_week) {
      //match now,do nothing
    }
    else
    {
      //the time is not reach,so reset all to begin
      nt.setHours(0);
      nt.setMinutes(0);
      nt.setSeconds(0);
      
      var maxday = _getmaxday(nt.getTime());
      
      //check circle
      //if all days in this month are not match,mean next month
      var begin_day = next;
      var check_again = false;
      
      var flag = true;
      do
      {
        
        next = this.day[dindex];
        
        //if day not in this month      and   circle check
        if (next > maxday || now > next || (check_again && begin_day == next)) {
          //next month
          nt.setMonth(nt.getMonth()+1);
          //just set day to 1
          nt.setDate(1);
          
          flag = false;
          
          break;
        }
        
        nt.setDate(next);
        
        now_week = nt.getDay();
        next_week = _getnext(now_week,this.week);
        next_week = this.week[next_week];
        
        //use the next day
        dindex++;
        if (dindex >= this.day.length) {
          dindex = 0;
        }
        
        //now we need check again
        check_again = true;
      }
      while(now_week != next_week);
      
      if(!flag)
      {
        //need check month
        continue;
      }
    }
    
    
    //check hour
    now = nt.getHours();
    next = _getnext(now,this.hour);
    next = this.hour[next];
    if (now == next) {
      //match now,do nothing
    }
    else
    {
      //the time is not reach,so reset all to begin
      nt.setHours(next);
      nt.setMinutes(0);
      nt.setSeconds(0);
      
      if (now > next) {
        //next day, this may be cause month + 1, so need check month again
        nt.setDate(nt.getDate() + 1);
        continue;
      }
    }
    
    
    //check minute
    now = nt.getMinutes();
    next = _getnext(now,this.minute);
    next = this.minute[next];
    if (now == next) {
      //match now,do nothing
    }
    else
    {
      //the time is not reach,so reset all to begin
      nt.setMinutes(next);
      nt.setSeconds(0);
      
      if (now > next) {
        //next hour, this may be cause month + 1, so need check month again
        nt.setHours(nt.getHours() + 1);
        continue;
      }
    }
    
    
    //check second
    now = nt.getSeconds();
    next = _getnext(now,this.second);
    next = this.second[next];
    if (now == next) {
      //match now,do nothing
    }
    else
    {
      nt.setSeconds(next);
      
      if (now > next) {
        //next minute, this may be cause month + 1, so need check month again
        nt.setMinutes(nt.getMinutes() + 1);
        continue;
      }
    }
    
    break;
  }
  
  return nt.getTime();
};



//internal helper functions
function _parse(field,min,max) {
  
  var ret = [];
  
  //replace the "*" to range , make it simple
  field = field.replace(/\*/g,min+"-"+max);
  
  //split commas
  var split = field.split(",");
  
  var err = false;
  
  //use obj key to avoid have the same value
  var obj = {};
  
  for (var i = 0; i < split.length; i++) {
    
    var match_ret = split[i].match(/^(\d+)(?:-(\d+))?(?:\/(\d+))?$/);
    
    if (match_ret === null) {
      //do not match anything, the format is error
      err = true;
      
      break;
    }
    else
    {
      //match 0 for global, 1 for small, 2 for big , 3 for step
      var small = parseInt(match_ret[1],10);
      var big = parseInt(match_ret[2],10) || small;
      var step = parseInt(match_ret[3],10) || 1;
      
      //make sure small in [min,max]
      if (small < min) {
        small += min;
      }
      else if (small > max) {
        small = (small % (max+1)) + min; 
      }
      //make sure big in [min,max]
      if (big < min) {
        big += min;
      }
      else if (big > max) {
        big = (big % (max+1)) + min; 
      }
      
      var index = small;
      //need add total len;
      if (small > big) {
        big = max-min+1+big;
      }
      
      while(index <= big)
      {
        if (index <= max) {
          obj[index] = 1;
        }
        else
        {
          //convert it into [min,max]
          obj[(index % (max+1)) + min] = 1;
        }
        
        index += step;
      }
      
    }
    
  }
  
  if (!err) {
    for(var key in obj)
    {
      ret.push(key*1);
    }
    ret.sort(function(a,b){return a - b;});
  }
  
  return ret;
}

//get the next field time, return the index of arr
//if t in arr, just return t
function _getnext(t,arr) {
  
  if (t <= arr[0] || t > arr[arr.length - 1]) {
    return 0;
  }
  else
  {
    return _next(t,arr,0,arr.length-1);  
  }
}

function _next(t,arr,start,end){
  
  if (start == end) {
    if (t < arr[start]) {
      return start;
    }
    else if (t == arr[start]) {
      return start;
    }
    else
    {
      return start+1;
    }
  }
  else
  {
    var mid = ~~((start+end)/2);
    
    if (t < arr[mid]) {
      return _next(t,arr,start,mid);
    }
    else if (t == arr[mid]) {
      return mid;
    }
    else
    {
      return _next(t,arr,mid+1,end);
    }
    
  }
}


//get the max day in current time
function _getmaxday(time) {
  var date = new Date(time);
  
  //set month to next,but date to 0, mean the last month end day
  date.setMonth(date.getMonth() + 1);
  date.setDate(0);
  
  return date.getDate();
}

module.exports = cron;
