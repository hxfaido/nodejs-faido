
//this cost less time than hjson
//msg header use binary :  1xxxxxxx ... 0xxxxxxx 
//len / step + mod


function hbinary(recvsize){
   
    this.len = 0;
	this.maxrecvsize = recvsize;
}

//parse buffer to get head , return offset for body, and body len
hbinary.prototype.decode = function(buffer, offset, end){
    
    if(offset >= end)
    {
	return {off:-1, len:-1};
    }
    
    var i;
    for(i = offset; i < end; i++){
        
        var tmp = buffer.readUInt8(i);
        
        //at end
        if( (tmp & 0x80) === 0)
        {
            this.len = (this.len << 7) + tmp;
            break;
        }
        else
        {
            this.len = (this.len << 7) + (tmp & 0x7f);
			if(this.len > this.maxrecvsize)
				break;
        }
    }
	
	//check body size
	if(this.len > this.maxrecvsize)
	{
        //reset
        this.len = 0;
		throw new Error("invalid binary head body size");	
	}
    
    //no more data now, head is not complete
    if (i == end) {
	return {off:-1, len:-1};
    }
    else
    {
        var ret = {off: i+1, len:this.len};
        
        //reset
        this.len = 0;
        return ret;
    }
};


//create head from body buffer
hbinary.prototype.encode = function(body){
    
    var len = body.length;
    
    var barr = [];
    var high = 0;       //the last high bit is 0 ,others are 1
    
    //we support len = 0
    do{
        
      var mod = len % 0x80;
      
      barr.push(mod | high);
      
      len = len >> 7;
      
      high = 0x80;
      
    } while(len !== 0);

    var buf = new Buffer(barr.length);
    
    //reverse write
    for(var i = 0; i < barr.length; i++)
    {
        buf.writeUInt8(barr[barr.length-i-1],i);
    }
    
    return buf;
};

module.exports = hbinary;

