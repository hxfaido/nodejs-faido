
//our global server object

//server event : "init" , "stop" , "dynamic"

var EventEmitter = require("events").EventEmitter;
var fn = require("./utils/fn");
//server status (0:not stop 1:begin stop 2:stopping)
var _stop_status = 0;

function server(debug,conf){
   
   EventEmitter.call(this);
   
   //store info
   this.debug = debug;
   this.conf = conf;
   this.CONST = require("./utils/const");

}

fn.inherit(server,EventEmitter);


//before invoke start, you can modify CONST and conf.

//obj is tcp handlers.  such as : {gameserver : handler}

server.prototype.start = function(obj){
   
   var begin = Date.now();
   
   init_server(this);

   init_dynamic(this);

   init_db(this);
   
   init_http(this);
   
   init_tcp(this,obj);
   
   init_hook(this);
   
   //set conf to user defined
   this.original_conf = this.conf;
   this.conf = this.conf.conf || {};
   
   var end_sys = Date.now();
   
   //init event after all ok
   try{
      this.emit("init");
   }
   catch(e){
      this.log_err(e);
   }
   var end_app = Date.now();
   
   this.log("server start ok, use time : %j ms(sys %j ms)" , end_app - begin , end_sys - begin);
};

server.prototype.stop = function(){

	//check stopping
	if(_stop_status == 2)
		return;
	
	_stop_status = 2; 
	
	var maxtime = 0;
	var inter_time = 1;
	if(this.debug){
		maxtime = 3000;
		inter_time = 100;
	}
	else{
		maxtime = this.CONST.SERVER.STOP_TIME;
		inter_time = this.CONST.LOG.FILE_FLUSHTIME;
	}
	
	this.log(this.CONST.LOG.STOP_LOG, "server will stop after <= %j ms ...", maxtime);
	
	var can_exit = false;
	var start = Date.now();
	var db_key = this.db ? Object.keys(this.db) : [];
	var self = this;
	var inter = setInterval(function(){

		if(can_exit)
		{
			clearInterval(inter);
			process.exit(0);
			return;
		}
	
		var finishall = true;
		for(var i = 0; i < db_key.length; i++)
		{
			if(!self.db[db_key[i]].dbfinish())
			{
				finishall = false;
				break;
			}
		}
		
		if(finishall)
		{
			self.log(self.CONST.LOG.STOP_LOG,"server is stop");
			can_exit = true;
			return;
		}
		
		if(Date.now() - start > maxtime)
		{
			self.log(self.CONST.LOG.STOP_LOG,"server is stop by timeout");
			can_exit = true;
			return;
		}
		
	},inter_time);
};


//------------ only for internal use, like class private function   --------------//
function init_server(self){
   
   //init log first
   var log_manager = require("./log/log");

   log_manager.init(self.debug, self.conf.log);

   //set server.log
   self.log = log_manager.log.bind(log_manager);
   self.log_err = log_manager.log.bind(log_manager,self.CONST.LOG.ERR_LOG);
   //set global.log compatible with older
   global.log = self.log;   
   
   
   //catch global exception -- you need use try catch in upper level ,when cause err ,server will be in unknown state.
   process.on("uncaughtException",function(e){
      
      self.log_err(e);
      //stop server when meet any err
      if(_stop_status > 0){
		self.stop();
      }
   });
   
   var event;
   if(self.debug){
      //catch ctrl+c
      event = "SIGINT";    
   }
   else
   {
      event = "SIGTERM";   
   }
   
    process.on(event,function(){

		if(_stop_status > 0)
			return;
		
		_stop_status = 1;

		self.log(self.CONST.LOG.STOP_LOG, "server begin stop...");

		//check upper get the event, which will invoke stop when finish.
		if(self.listeners("stop").length > 0){

			self.emit("stop");
		}
		else
		{
			self.stop();
		}
    });
   
   
   //set global Period  
   global.setPeriod = function(cb,time){
      var p = new _period(cb,time,self.log_err);
      _period_start(p);
      return p;
   };
   
   global.clearPeriod = function(p){
      //need check type
      if(p instanceof _period){
         _period_stop(p);
      }
   };
}

function init_dynamic(self){

   var fs = require("fs");  
   var config = require("./utils/config");
   var dynamic_path = "./dynamic.ini";
   
   //check is exist
   if (fs.existsSync(dynamic_path)) {
      
      //watch dynamic file
      var watch_file = function(){
         var watcher = fs.watch(dynamic_path, function(event, filename){
            if(event === "change")
            {
               config.read(dynamic_path,function(err,dynamicconf){
                  if(err)
                  {
                     self.log_err("read " + dynamic_path + " failed : " + err);
                  }
                  else
                  {
                     try{
			fn.extend(self.dynamic, dynamicconf);
			//emit "dynamic" event
			self.emit("dynamic", self.dynamic);
                     }
                     catch(e){
			self.log_err(e);
                     }
                  }
               });
               //must close it and restart (fixed bug.)
               watcher.close();
               watch_file();
            }
         }); 
      };
      
      try
      {
         //read sync first
         var dynamic = config.readsync(dynamic_path);
         self.dynamic = dynamic;
       
         //set watch for it
         watch_file();
      }catch(err){
         self.log_err("read " + dynamic_path + " failed : " + err); 
      }
   }  
}

function init_db(self){
   
   //handle db
   var db_conf = self.conf.db;
   if(db_conf && typeof db_conf === "object")
   {
      var db = require("./mongo/db");

      //check ip is local
      var os = require("os");
      var net_interface = os.networkInterfaces();
      function check_local(dbip){
		 //win32 does not have unix socket.
 		 if(process.platform == "win32")
			return false;
		
         if(dbip)
         {
            for(var netif_key in net_interface)
            {
               var netif = net_interface[netif_key];
               for(var i = 0; i < netif.length; i++)
               {
                  if(netif[i].address == dbip)
                  {
                     return true;
                  }
               }
            }
            return false;
         }
         else
         {
            return true;
         }
      }

      self.db = {};
      for(var key in db_conf)
      {
         var value = db_conf[key];
	 
         if (value && typeof value === "object") {
            //if local ip , we use default unix socket.   
            self.db[key] = new db(check_local(value.dbip) ? undefined : value.dbip, value.dbport, value.dbname, value.dbpool, value.dbsure);
         }
      }    
   }
}

function init_http(self){
   
   var http_module = null;
   
   //handle http
   var http_conf = self.conf.http; 
   if(http_conf && typeof http_conf === "object")
   {
      http_module = require("./network/http");
      self.http = http_module.init_http(http_conf);
   }
   
   //set get and post
   self.__defineGetter__("http_get",function(){
      if(http_module === null)
      {
         http_module = require("./network/http");
      }
      return http_module.get;
   });
   
   self.__defineGetter__("http_post",function(){
      if(http_module === null)
      {
         http_module = require("./network/http");
      }
      return http_module.post;
   });   
}

function init_tcp(self,hobj){
   
   //tcp maybe always use.
   var tcp = require("./network/tcp");
   
   if(hobj && typeof hobj === "object")
   {
      for(var key in hobj)
      {
         var handler = hobj[key];
         var info = self.conf[key];
         
         if (info && typeof info === "object" && handler && typeof handler === "object") {
            
            //handle opts : {head : h, body : b, crypto : c}
            var opts = {head : self.CONST.NET.HEAD_BINARY};
            var crypto = info.crypto * 1;
            if(crypto > 0){
               //to client, need crypto and bson (small msg size)
               opts.body = self.CONST.NET.BODY_BSON;
               opts.crypto = self.CONST.NET.CRYPTO_AES;
            }
            else
            {
               //to internal, do not crypto and use json, fast speed
               opts.body = self.CONST.NET.BODY_JSON;
               opts.crypto = self.CONST.NET.CRYPTO_DUMMY;
            }
            
            //now we just check have ip to determine client or server
            if (info.ip !== undefined) {
               var _count = Number(info.count);
               if(isNaN(_count) || _count <= 0)
               {
                  _count = 1;
               }
               while(_count-- > 0)
               {
                  tcp.start_netclient(info.ip, info.port, handler, opts);
               }
            }
            else
            {
			   opts.ipv6 = info.ipv6;
               tcp.start_netserver(info.port, handler, opts);
            }
         }
         else
         {
            self.log_err("init tcp %j failed , type may be invalid.",key);
         }
      }
   }   
   
   //set tcp function
   self.__defineGetter__("start_netserver",function(){
      return tcp.start_netserver;
   });
   
   self.__defineGetter__("start_netclient",function(){
      return tcp.start_netclient;
   });     
}

function init_hook(self){
   //hook only when in debug mode
   if(self.debug && self.CONST.SERVER.HOOK_TIMER){
      
      //hook all timer
      var timer_timeout = new _timer("setTimeout","clearTimeout");
      var timer_interval = new _timer("setInterval","clearInterval");
      var timer_period = new _timer("setPeriod","clearPeriod");
      
      self.print_timer = function(){
	 
         self.log("Interval  :  %j",timer_interval.timers);
         self.log("Timeout  :  %j",timer_timeout.timers);
         self.log("Period  :  %j",timer_period.timers);	 
      };
   }
   else
   {
      self.print_timer = function(){};
   }
}



module.exports = server;


//internal period
var cron_class = require("./utils/cron");

//in timers.js  Timeout values > TIMEOUT_MAX are set to 1.
var TIMEOUT_MAX = 2147483647;	//2^31-1
//store before hook
var timeout_start_fn = setTimeout;
var timeout_stop_fn = clearTimeout;

function _period(cb,time,log_err){
   
   //store internal data
   Object.defineProperty(this,"_internal_data_",{
      value : {},
      writable : true,
      enumerable : false,
      configurable : false
   });
   
   if(typeof cb != "function"){
      log_err("period %j callback must be a function.",time);
      return;
   }
   
   var cron = new cron_class(time);
   
   var cron_err = cron.geterr();
   if(cron_err){
      log_err("period %j err : %j",time,cron_err);
      return;
   }
   
   this._internal_data_.log_err = log_err;
   this._internal_data_.cron = cron;
   this._internal_data_.time = time;
   this._internal_data_.cb = cb;
   this._internal_data_.lefttime = 0;
}

function _period_start(self){
   
	var next_t = self._internal_data_.lefttime;
	if(next_t <= 0)
	{
		//get next from right now
		var now = Date.now();
		next_t = self._internal_data_.cron.getnext(now);
		//get diff
		next_t -= now;   
	}

	//reset left time
	self._internal_data_.lefttime = 0;	
	
	//check timeout max
	if(next_t > TIMEOUT_MAX){
		self._internal_data_.lefttime = next_t - TIMEOUT_MAX;
		next_t = TIMEOUT_MAX;
	}

	self._internal_data_.timeout = timeout_start_fn(_period_cb,next_t,self);	
}

function _period_stop(self){
   if(self._internal_data_.timeout){
      timeout_stop_fn(self._internal_data_.timeout);
   }
}

function _period_cb(self){
	
	//check have left time
   if(self._internal_data_.lefttime <= 0)
   {
	   //invoke callback, we need catch err
	   try
	   {
		  self._internal_data_.cb();
	   }
	   catch(e)
	   {
		  self._internal_data_.log_err(e);
	   }	   
   }	   
  
   //reset timeout
   self._internal_data_.timeout = null;
   
   _period_start(self);
}



//----------- internal global timer ------------------//
function _timer(start,stop){
   
   //store name and function
   this.start_name = start;
   this.stop_name = stop;
   this.start = global[start];
   this.stop = global[stop];
   
   
   //hook start,stop
   global[start] = this.hook_start = _timer_start.bind(this);
   global[stop] = this.hook_stop = _timer_stop.bind(this);
   
   
   this.timers = {};
   
   //do it specially
   if(start === "setTimeout"){
      this.spec = true;
   }
   
   _timer.hooker.push(this);
}

//we need reset all hook before , since the clearInterval use clearTimeout directly
_timer.hooker = [];

function before(){
   
   for(var i = 0; i < _timer.hooker.length; i++)
   {
      var hooker = _timer.hooker[i];
      
      global[hooker.start_name] = hooker.start;
      global[hooker.stop_name] = hooker.stop;   
   }
}

function after(){
   
   for(var i = 0; i < _timer.hooker.length; i++)
   {
      var hooker = _timer.hooker[i];
      
      global[hooker.start_name] = hooker.hook_start;
      global[hooker.stop_name] = hooker.hook_stop;   
   }
}

function _timer_start(cb){
   
   before();
   
   var ret,my_ret;
   
   //timeout will remove when callback
   if(this.spec){
      var self = this;
      var wrapper = function(){
         if(my_ret){
            _timer_stop.call(self,my_ret);
         }
         cb.apply(null,arguments);			//timeout have added try catch internal.
      };
      ret = this.start.apply(null,[].concat(wrapper, Array.prototype.slice.call(arguments, 1)));
   }
   else
   {
      ret = this.start.apply(null,arguments);
   }
 
   var fline_str = fn.fline(2);
   
   if(this.timers[fline_str] === undefined)
   {
      this.timers[fline_str] = 1;
   }
   else
   {
      this.timers[fline_str]++;
   }
   
   my_ret = {fline : fline_str, ret : ret};
   
   after();
   
   return my_ret;
}

function _timer_stop(obj){
   
   before();
   
   if(typeof obj == "object"){
      
      var fline_str = obj.fline;
      
      if(this.timers[fline_str] !== undefined)
      {
         this.timers[fline_str]--;
	 
         if(this.timers[fline_str] === 0){
            delete this.timers[fline_str];
         }
      }
      
      this.stop(obj.ret);
   }
   
   after();
}

