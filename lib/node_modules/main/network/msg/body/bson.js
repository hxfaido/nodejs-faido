//------------------------ our bson msg format -----------------------//
//--the speed is slow than stringif,but the length is more less     --//
//--we can use c++ to implement this in future,such as mongodb bson --//

//value type - one byte
var value_type = {
  "string1" : 1,            //the str len is one byte
  "string2" : 2,            //the str len is two byte
  "string4" : 3,            //the str len is four byte
  "int1" : 4,
  "int2" : 5,
  "int4" : 6,
  "uint1" : 7,
  "uint2" : 8,
  "uint4" : 9,
  "double" : 10,
  "doublestr" : 11,         //use string to store ,if it is less than 8.
  "long" : 12,				//use for long number
  "arr" : 20,
  "obj" : 30,
  
  "end" : 255               //special type for end.
};

var bson_head = 188;
var max_key_len = 250;
var key_index_1 = max_key_len + 1;    //key index one byte
var key_index_2 = max_key_len + 2;    //key index two byte
var key_dummy_len = 255;              //for dummy end key

var long_safe_max = 9007199254740991;
var long_safe_min = -9007199254740991;

function bson(){
  
  this.encode_caches = [];
  this.encode_key_cache = {};
  this.encode_key_len = 0;
  
  this.decode_key_cache = {};
  this.decode_key_len = 0;
}

//all help function for encode

//obj bson format:
//1b key len + key + 1b value type + value , and all number use LE
//obj key len must less than max_key_len.
bson.prototype.encode_obj = function(obj, off, isroot){
  
  for(var key in obj){
    
    var value = obj[key];
    
    //ingore invalid value
    if(value === undefined || value === null || ( typeof value === "number" && isNaN(value) ) || typeof value === "function")
    {
      continue;
    }
   
    off = this.encode_key(key,off);
    
    //encode value
    off = this.encode_value(obj[key],off);
  }
  
  if(!isroot)
  {
    //need the end type, also need a dummy empty key for decode
    this.encode_caches.push({fn:"writeUInt8", val:key_dummy_len, off:off});
    off += 1;
    
    this.encode_caches.push({fn:"writeUInt8", val:value_type.end, off:off});
    off += 1;
  }
  
  return off;
  
};

bson.prototype.encode_key = function(key, off){
  //key is always one byte
  if(key.length > max_key_len){
    throw new Error("object key length is more than max : " + max_key_len);
  }
  
  //check key is in cache
  var index = this.encode_key_cache[key];
  if(index === undefined){
    this.encode_caches.push({fn:"writeUInt8", val:key.length, off:off});
    off += 1;
    //write will check empty string,so just push.
    this.encode_caches.push({fn:"write", val:key, off:off});
    off += key.length;
    
    this.encode_key_cache[key] = ++this.encode_key_len;
  }
  else
  {
    if(index <= 0xff)
    {
      //use uint8
      this.encode_caches.push({fn:"writeUInt8", val:key_index_1, off:off});
      off += 1;
      this.encode_caches.push({fn:"writeUInt8", val:index, off:off});
      off += 1;         
    }
    else if(index <= 0xffff)
    {
      //use uint16
      this.encode_caches.push({fn:"writeUInt8", val:key_index_2, off:off});
      off += 1;
      this.encode_caches.push({fn:"writeUInt16LE", val:index, off:off});
      off += 2;        
    }
    else{
      throw new Error("object total different key is more than max : 65535.");
    }
  }

  return off;
};

bson.prototype.encode_arr = function(arr, off){
  
  for(var i = 0; i < arr.length; i++){
    //encode value
    off = this.encode_value(arr[i],off);  
  }
  
  //need the end type
  this.encode_caches.push({fn:"writeUInt8", val:value_type.end, off:off});
  off += 1;
  
  return off;
};

bson.prototype.encode_value = function(value,off){
  
  if(typeof value === "number"){
    
    //check is int  
    if(value % 1 === 0)
    {
      if(value < -0x80000000 || value > 0xffffffff)
      {
		//check is safe
		if(value < long_safe_min || value > long_safe_max)
		{
			throw new Error("bson object long number is exceed double safe value");
		}
		  
        //must use double to store long type
        this.encode_caches.push({fn:"writeUInt8", val:value_type.long, off:off});
        off += 1;
        this.encode_caches.push({fn:"writeDoubleLE", val:value, off:off});
        off += 8;
      }
      else if(value < -0x8000)
      {
        //use int32
        this.encode_caches.push({fn:"writeUInt8", val:value_type.int4, off:off});
        off += 1;
        this.encode_caches.push({fn:"writeInt32LE", val:value, off:off});
        off += 4;
      }
      else if(value < -0x80)
      {
        //use int16
        this.encode_caches.push({fn:"writeUInt8", val:value_type.int2, off:off});
        off += 1;
        this.encode_caches.push({fn:"writeInt16LE", val:value, off:off});
        off += 2;
      }
      else if(value < 0)
      {
        //use int8
        this.encode_caches.push({fn:"writeUInt8", val:value_type.int1, off:off});
        off += 1;
        this.encode_caches.push({fn:"writeInt8", val:value, off:off});
        off += 1;        
      }
      else if(value <= 0xff)
      {
        //use uint8
        this.encode_caches.push({fn:"writeUInt8", val:value_type.uint1, off:off});
        off += 1;
        this.encode_caches.push({fn:"writeUInt8", val:value, off:off});
        off += 1;         
      }
      else if(value <= 0xffff)
      {
        //use uint16
        this.encode_caches.push({fn:"writeUInt8", val:value_type.uint2, off:off});
        off += 1;
        this.encode_caches.push({fn:"writeUInt16LE", val:value, off:off});
        off += 2;        
      }
      else
      {
        //use uint32
        this.encode_caches.push({fn:"writeUInt8", val:value_type.uint4, off:off});
        off += 1;
        this.encode_caches.push({fn:"writeUInt32LE", val:value, off:off});
        off += 4;        
      }
    }
    else
    {
      //double
      
      var value_str = value.toString();
      if(value_str.length < 8)
      {
        //use double string
        this.encode_caches.push({fn:"writeUInt8", val:value_type.doublestr, off:off});
        off += 1;
        
        //length must less than 1 byte
        this.encode_caches.push({fn:"writeUInt8", val:value_str.length, off:off});
        off += 1;
        
        this.encode_caches.push({fn:"write", val:value_str, off:off});
        off += value_str.length;        
      }
      else
      {
        this.encode_caches.push({fn:"writeUInt8", val:value_type.double, off:off});
        off += 1;
        this.encode_caches.push({fn:"writeDoubleLE", val:value, off:off});
        off += 8;
      }
    }
  }
  else if(typeof value === "string"){
    //we need actual byte length of a string
    var len = Buffer.byteLength(value,"utf8");
    
    if(len <= 0xff)
    {
      //use uint8
      this.encode_caches.push({fn:"writeUInt8", val:value_type.string1, off:off});
      off += 1;
      this.encode_caches.push({fn:"writeUInt8", val:len, off:off});
      off += 1;         
    }
    else if(len <= 0xffff)
    {
      //use uint16
      this.encode_caches.push({fn:"writeUInt8", val:value_type.string2, off:off});
      off += 1;
      this.encode_caches.push({fn:"writeUInt16LE", val:len, off:off});
      off += 2;        
    }
    else
    {
      //use uint32
      this.encode_caches.push({fn:"writeUInt8", val:value_type.string4, off:off});
      off += 1;
      this.encode_caches.push({fn:"writeUInt32LE", val:len, off:off});
      off += 4;        
    }
    
    //check empty string
    if(len > 0)
    {
      this.encode_caches.push({fn:"write", val:value, off:off});
      off += len;  
    }
  }
  else if(typeof value === "boolean"){
    //convert to 0 or 1
    this.encode_caches.push({fn:"writeUInt8", val:value_type.uint1, off:off});
    off += 1;
    
    this.encode_caches.push({fn:"writeUInt8", val:value?1:0, off:off});
    off += 1;
  }
  else
  {
    //always obj
    
    if(value instanceof Array)
    {
      this.encode_caches.push({fn:"writeUInt8", val:value_type.arr, off:off});
      off += 1;
      off = this.encode_arr(value,off);
    }
    else
    {
      this.encode_caches.push({fn:"writeUInt8", val:value_type.obj, off:off});
      off += 1;
      off = this.encode_obj(value,off,false);
    }
  }
  
  return off;
};

//if obj is empty,the buf length will be zero
bson.prototype.encode = function(obj){
  
  try{
    
	//one byte for head
    var len = this.encode_obj(obj,1,true);   
    
    //now we know the total len
    var buf = new Buffer(len);
	buf[0] = bson_head;
    
    //do all write
    for(var i = 0; i < this.encode_caches.length; i++)
    {
      var cmd = this.encode_caches[i];
      buf[cmd.fn](cmd.val,cmd.off);
    }
    
    //clear
    this.encode_caches = [];
    this.encode_key_cache = {};
    this.encode_key_len = 0;
    
    return buf;
  }
  catch(e){
    
    //clear
    this.encode_caches = [];
    this.encode_key_cache = {};
    this.encode_key_len = 0;
    
    throw e;
  }
};



//all help function for decode
bson.prototype.decode_obj = function(buf,off){
  
  var obj = {};
  
  while(off < buf.length)
  {
    //get key
    var key_ret = this.decode_key(buf,off);
    off = key_ret.off;
    
    var value_ret = this.decode_value(buf,off);
    off = value_ret.off;
    
    //check obj end
    if(value_ret.value === null)
    {
      break;  
    }
    else
    {
      obj[key_ret.value] = value_ret.value;
    }
  }
  
  return {value:obj, off:off};
};

bson.prototype.decode_key = function(buf,off){
  
  //get key len
  var key_len = buf.readUInt8(off);
  off += 1;
  
  var key,index;
  if(key_len <= max_key_len){
    key = buf.toString("utf8",off,off+key_len);
    off += key_len;
    this.decode_key_cache[++this.decode_key_len] = key;
  }
  else if(key_len === key_index_1){
    index = buf.readUInt8(off);
    off += 1;
    key = this.decode_key_cache[index];
    if(key === undefined){
      throw new Error("key index is invalid");
    }
  }
  else if(key_len === key_index_2){
    index = buf.readUInt16LE(off);
    off += 2;
    key = this.decode_key_cache[index];
    if(key === undefined){
      throw new Error("key index is invalid");
    }
  }
  else if(key_len === key_dummy_len){
    //set a dummy key,do nothing
  }
  else{
    throw new Error("key len is invalid");
  }
  
  return {value:key, off:off};
};

bson.prototype.decode_arr = function(buf,off){
  
  var arr = [];
  
  while(off < buf.length)
  { 
    var ret = this.decode_value(buf,off);
    off = ret.off;
    
    //check obj end
    if(ret.value === null)
    {
      break;  
    }
    else
    {
      arr.push(ret.value);
    }
  }
  
  return {value:arr, off:off};
  
};

bson.prototype.decode_value = function(buf,off){
  
  //get type first
  var type = buf.readUInt8(off);
  off += 1;
  
  var ret = {};
  var len;
  if(type === value_type.string1)
  {
    len = buf.readUInt8(off);
    off += 1;
    
    ret.value = buf.toString("utf8",off,off+len);
    off += len;
  }
  else if(type === value_type.string2)
  {
    len = buf.readUInt16LE(off);
    off += 2;
    
    ret.value = buf.toString("utf8",off,off+len);
    off += len;    
  }
  else if(type === value_type.string4)
  {
    len = buf.readUInt32LE(off);
    off += 4;
    
    ret.value = buf.toString("utf8",off,off+len);
    off += len;    
  }
  else if(type === value_type.int1)
  {
    ret.value = buf.readInt8(off);
    off += 1;
  }
  else if(type === value_type.int2)
  {
    ret.value = buf.readInt16LE(off);
    off += 2;    
  }
  else if(type === value_type.int4)
  {
    ret.value = buf.readInt32LE(off);
    off += 4;    
  }
  else if(type === value_type.uint1)
  {
    ret.value = buf.readUInt8(off);
    off += 1;    
  }
  else if(type === value_type.uint2)
  {
    ret.value = buf.readUInt16LE(off);
    off += 2;        
  }
  else if(type === value_type.uint4)
  {
    ret.value = buf.readUInt32LE(off);
    off += 4;     
  }
  else if(type === value_type.double)
  {
    ret.value = buf.readDoubleLE(off);
    off += 8;     
  }
  else if(type === value_type.doublestr)
  {
    len = buf.readUInt8(off);
    off += 1;
    
    ret.value = Number(buf.toString("utf8",off,off+len));
    off += len;    
  }
  else if(type === value_type.long)
  {
    ret.value = buf.readDoubleLE(off);
    off += 8;     
  }
  else if(type === value_type.arr)
  {
    return this.decode_arr(buf,off);
  }
  else if(type === value_type.obj)
  {
    return this.decode_obj(buf,off);
  }
  else if(type === value_type.end)
  {
    //set it to null , mean end
    ret.value = null;
  }
  else
  {
    throw new Error("unkowned value type");
  }
  
  ret.off = off;
  
  return ret;
};



bson.prototype.decode = function(buf){
  
  try{
    
	//check head first
	if(buf[0] != bson_head)
	{
		throw new Error("invalid bson head");
	}
	
    var ret = this.decode_obj(buf,1);
    
    this.decode_key_cache = {};
    this.decode_key_len = 0;
    
    return ret.value;
  }
  catch(e)
  {
    this.decode_key_cache = {};
    this.decode_key_len = 0;
    
    throw e;
  }
};



module.exports = bson;

