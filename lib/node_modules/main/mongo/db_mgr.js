var db_sure = require("./db_sure");
var CONST = require("../utils/const");
var log = require("../log/log");
log = log.log.bind(log,CONST.LOG.DB_LOG);

function db_mgr(id,dbsure){
   
   //create db sure
   this.sure = new db_sure(id,dbsure);
   
   this.id = id;
   
   //store db instance
   this.db = null;

   //cache when not connected
   this.caches = [];
}

db_mgr.prototype.init = function(mongo_db){
  
   //init db sure first;
   this.sure.init(mongo_db);
  
   var self = this;
  
   //catch all events
   mongo_db.on("open",function(){
      
      self.db = mongo_db;
      self.flush();
      
      log(self.id + " connect db ok .");
   });
   
   mongo_db.on("reconnect",function(){
      
      self.db = mongo_db;
      self.flush();
      
      log(self.id + " reconnect db ok .");
   });
   
   //this is from socket "error" event, and db server will close directly, so will not cause "close" event
   mongo_db.on("error",function(err){
      
      //reset db
      self.db = null;
      
      log(self.id + " meet (network) err : " + err);
   });
   
   //this is from socket "close" event, if no err, mean tcp recv "FIN"
   mongo_db.on("close",function(){
      
      //reset db
      self.db = null;
      
      log(self.id + " db close !");
   });
   
   mongo_db.on("parseError",function(){
      
      //reset db
      self.db = null;
      
      //may be the driver do not support this db version 
      log(self.id + " parseError(may be the driver do not support the db version) , db driver will stop forever!");
   });   
};

db_mgr.prototype.request = function(){
   
   //create db request
   var req = this.sure.create.apply(this.sure,arguments);
 
   //when db connect , and no req in cache, just send
   if (this.db !== null && this.caches.length === 0) {
      this.sure.send(req);      
   }
   else
   {
      this.caches.push(req); 
   }
};

//flush all caches
db_mgr.prototype.flush = function(index){
   
   if (index === undefined) {
      index = 0;
   }
   else
   {
      //db may be null (connection is closed) when in setImmediate,
      //so we need delete the req which is be sent.
      if(this.db === null)
      {
         this.caches.splice(0,index);
         
         log(this.id +" caches left : " + this.caches.length);
         
         return;
      }
   }
   
   var max = index + CONST.DB.MAX_REQ;
   var need_next = max < this.caches.length;
   if (!need_next) {
      max = this.caches.length;
   }
   
   for(;index < max; index++)
   {
      //send request
      this.sure.send(this.caches[index]);
   }
   
   //set in nexttick ,avoid other fd events delay
   if (need_next) {
      setImmediate(this.flush.bind(this),index);
   }
   else
   {
      //reset
      this.caches = [];
   }
};

module.exports = db_mgr;


