//our tcp interface
//notice that : msg encode and decode are all sync , so the order is correct.

var fs = require("fs");
var net = require("net");
var util = require("util");
var msg = require("./msg/msg");
var msg_handler = require("./handler");
var _const = require("../utils/const");
var CONST = _const.NET;
var CONST_MSG = _const.SYS_MSG;
var log_manager = require("../log/log");

_log = log_manager.log.bind(log_manager,_const.LOG.DEFAULT_LOG);
_err = log_manager.log.bind(log_manager,_const.LOG.ERR_LOG);

//for heartbeat msg
var _heartbeat_msg = {};
_heartbeat_msg[CONST.DEFAULT_MSGID] = CONST_MSG.HEARTBEAT;

//base connection
function base_connection(s,msg,handler){

    //store internal data
    Object.defineProperty(this,"_internal_data_",{
       value : {},
       writable : true,
       enumerable : false,
       configurable : false
    });
    
    //notice that s will be reset when meet 'error' or 'end' event , or user destroy it manually
    this._internal_data_.s = s;
    this._internal_data_.msg = msg;
    this._internal_data_.handler = handler;
}

//set msg
base_connection.prototype.setbody = function(body){
    this._internal_data_.msg.setbody(body);
};

base_connection.prototype.setcrypto = function(crypto){
    this._internal_data_.msg.setcrypto(crypto);
}; 

base_connection.prototype.sethead = function(head,recvsize){
	recvsize = Number(recvsize);
	if(recvsize > 0)
		this._internal_data_.msg.sethead(head, recvsize);
	else
		this._internal_data_.msg.sethead(head, CONST.RECV_MSGSIZE);
};

base_connection.prototype.sethandler = function(handler){
    this._internal_data_.handler.sethandler(handler);
};

base_connection.prototype.destroy = function(){
    
    if(this._internal_data_.s !== null){
        
        this._internal_data_.s.destroySoon();
        //reset the s
        this._internal_data_.s = null;
    }
};

//msg must use utf8 json format.
base_connection.prototype.send = function(type,msg){
    
    var s = this._internal_data_.s;
    
    if(s === null)
    {
        return;
    }

    if(arguments.length == 1)
    {
        msg = type;
        type = undefined;
    }
    
    //msg should be object
    if(Object.prototype.toString.call(msg) == "[object Object]")
    {
        if(type !== undefined){
            msg[CONST.DEFAULT_MSGID] = type;
        }
        
        //check MSGID
        if(msg[CONST.DEFAULT_MSGID] !== undefined){
            
            try{
                
                //filter
                filter(msg);
                
                var ret = this._internal_data_.msg.encode(msg);
                
                s.write(ret.head);
                s.write(ret.body);
            }
            catch(e){
                _err(e + " encode msg failed , %j",msg);
            } 
        }
    }
};


//------------- for client connection ----------------//
function client_connection(){
    
    base_connection.apply(this,arguments);
    
    //set retry
    this._internal_data_.retry = CONST.DEFAULT_RETRY;
    
    this._internal_data_.timeout = CONST.TIMEOUT_HEATBEAT;
    
    //set connected flag
    this._internal_data_.connected = false;
}
util.inherits(client_connection,base_connection);

//if we already start reconnect timeout, it will not let it stop.
client_connection.prototype.setretry = function(isretry){
    
    this._internal_data_.retry = isretry;
};

client_connection.prototype.settimeout = function(time,cb){
    
    var _internal = this._internal_data_;
    
    //store the timeout and cb
    _internal.timeout = time;
    _internal.timeout_cb = cb;
    
    //set the time
    if(_internal.s !== null)
    {
        _internal.s.setTimeout(time);
    }
};


//------------- for server connection ----------------//
function server_connection(){
    
    base_connection.apply(this,arguments);
    
    var self = this;
    
    //server socket is create when connected.
    var s = this._internal_data_.s;
    
    //set timeout to close
    s.setTimeout(CONST.TIMEOUT); 
    s.addListener("timeout", function() {
       
        _log("client : " + self.remoteAddress + "[" + self.remotePort + "] is closed by timeout.");
        
        self.destroy();
    });
    
    //since the 'close' event will be invoke after the uv_close finish, we need reset s before it
    s.on("error",function(e){
        self._internal_data_.s = null;
    });
    
    s.on("end",function(){
        self._internal_data_.s = null;
    });
    
    
    s.on("close",function(){
        onclose(self);
    });
}
util.inherits(server_connection,base_connection);

//0 mean ,not check timeout
server_connection.prototype.settimeout = function(time){
    
    //set the time
    if(this._internal_data_.s !== null)
    {
        this._internal_data_.s.setTimeout(time);
    }
};


//--------------------------- exports fn -----------------------//

//start a server
//opts: {head : h, body : b, crypto : c}
exports.start_netserver = function(port,handler,opts){
    
    opts = opts || {};
    
    var server = net.createServer(function(s){
        //native socket will store the js s, no need to store in global.
        var self = new server_connection(s, new msg(opts.head,opts.body,opts.crypto), new msg_handler(handler));
        
        //do init
        onconnect(self,port);
    });
    
    //port can be unix path
    server.listen(port, opts.ipv6 ? "::" : "0.0.0.0", CONST.DEFAULT_BACKLOG, function(){
        _log("listen on port : " + port + " ok!");
       
        //we need rm the unix socket path when stop.
        if(typeof port === "string"){
            
            process.on("exit",function(){
                fs.unlinkSync(port);
            });  
        }
    });
    
    return server;
};

//start a client
//opts: {head : h, body : b, crypto : c}
exports.start_netclient = function(ip,port,handler,opts){
    
    opts = opts || {};
    
    var client = new client_connection(null, new msg(opts.head,opts.body,opts.crypto), new msg_handler(handler));
    
    connect(client,ip,port);
    
    return client;
};





// --------------- only for internal use ------------------- //
function onconnect(self,port){
    
    var _internal = self._internal_data_;

    //since in node.js the unix socket not have address info,we need set by self.     
    if(typeof port === "string")
    {
        self.remoteAddress = "";
        self.remotePort = port;
        
        self.localAddress = "";
        self.localPort = port;
    }
    else
    {
        self.remoteAddress = _internal.s.remoteAddress;
        self.remotePort = _internal.s.remotePort;
        
        self.localAddress = _internal.s.localAddress;
        self.localPort = _internal.s.localPort;        
    }
    
    //set data handler
    _internal.s.ondata = function(buffer,offset,end){
        
        try
        {
            var ret = {off : offset};
           
            do
            {
                //reset offset
                offset = ret.off;
                
                ret = _internal.msg.decode(buffer,offset,end);
                
                if(ret.msg !== null)
                {
                    //filter
                    filter(ret.msg);
                    
                    //handle msg
                    _internal.handler.handle(ret.msg, self);
                }
                
            }while(ret.msg !== null);
        }
        catch(e){
            _log(e + " , msg decode failed , close client : " + self.remoteAddress + "[" + self.remotePort + "]");
            
            self.destroy();
        }
    };  
    
    //connect msg
    var connect_msg = {};
    connect_msg[CONST.DEFAULT_MSGID] = CONST_MSG.CONNECT;
    _internal.handler.handle(connect_msg, self);
}

//close - the s should be reset yet.
function onclose(self){
    
    var _internal = self._internal_data_;
    
    //close msg
    var close_msg = {};
    close_msg[CONST.DEFAULT_MSGID] = CONST_MSG.CLOSE;
    _internal.handler.handle(close_msg, self);
}

//client start connect
function connect(self,ip,port){
    
    var _internal = self._internal_data_;
    
    var s = net.connect(port, ip, function() {
        
        //do init after connected
        onconnect(self,port);
        
        //set connected flag
        _internal.connected = true;
        
        //set timeout
        s.setTimeout(_internal.timeout); 
        s.addListener("timeout", function() {
           
            if(typeof _internal.timeout_cb == "function"){
                _internal.timeout_cb(); 
            }
            else
            {
                self.send(_heartbeat_msg);
            }
        }); 
    });
    
    //since the 'close' event will be invoke after the uv_close finish, we need reset s before it
    s.on("error",function(e){
        self._internal_data_.s = null;
    });
    
    s.on("end",function(){
        self._internal_data_.s = null;
    });
    
    s.on("close",function(){
        
        //check we need retry -- if user destroy the connection, we will also reconnnect if retry.
        if(_internal.retry){
            
            setTimeout(function(){
               
               _log("reconnecting to server : " + ip + "[" + port + "]");
               
               connect(self,ip,port);
               
            },CONST.DEFAULT_RETRYTIME);
        }
        
        //invoke close only we have connected
        if(_internal.connected)
        {
            onclose(self);
            
            _internal.connected = false;
        }
    });
    
    //set s
    _internal.s = s;
}

//filter msg
function filter(msg){
    
    //msg id must not use sys id, HEARTBEAT is ok.
    var msgid = msg[CONST.DEFAULT_MSGID];
    if(msgid == CONST_MSG.CONNECT || msgid == CONST_MSG.CLOSE || msgid == CONST_MSG.COMMON)
    {
        throw new Error("msg id must not use sys id");
    }
}

