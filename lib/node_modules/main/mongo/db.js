
//mongodb 2.8 will have collection,docments level lock
//before 2.8 , use db level lock

//**** notice ****//
//1.
//test success in db driver: "1.3.23" , "1.4.29"
//it may be compatible with db driver 1.x
//we support the same collection operator as order, different may be not as order(no matter this).

//2.we use local unix socket as default.

//3.
//db request will cache , so we you insert a array, and update the arr use push method quikely , will cause the array some data insert twice
//how to solve the problem?
// a. array has little data, just use set all to update
// b. when you insert the array, create a copy for the obj, use the copy to send db request


var CONST = require("../utils/const").DB;
var mongo = require("mongodb");
var db_hook = require("./db_hook");
var db_mgr = require("./db_mgr");


//----------------------  db wrapper ---------------------------//
function db(ip,port,name,pool, sure){

	this.ip = ip || CONST.DEFAULT_HOST;
	this.port = port || CONST.DEFAULT_PORT;
	this.name = name || CONST.DEFAULT_NAME;
	this.poolsize = pool || CONST.DEFAULT_POOLSIZE;

	//db write command
	this.db_wait = 0;

	//create manager : use dbname[ip:port] as id
	this.db_mgr = new db_mgr(this.name + "[" + this.ip + ":" + this.port + "]", sure === undefined ? CONST.DEFAULT_SURE : !!sure);


	//start connect db

	var server = new mongo.Server(this.ip, this.port, {auto_reconnect: true, poolSize: this.poolsize});

	//1. set write corcern to 1, let mongod confirms of the write operation.
	//   acknowledged write concern allows clients to catch network, duplicate key, and other errors
	//   so the operation callback mean it has finished.
	//2. set the retry connect times to max. (retryMiliSeconds {Number, default:5000}, number of milliseconds between retries.)
	var mongo_db = new mongo.Db(this.name, server, { w: 1, numberOfRetries: Number.MAX_VALUE, retryMiliSeconds: CONST.RECONNECT_TIME , native_parser : 1});

	//check poolsize
	if (this.poolsize > 1) {
		//need hook db, to support the same collection use the same connection.
		//and let the db hook catch event first.
		this.hook = new db_hook(mongo_db);
	}

	this.db_mgr.init(mongo_db);

	//start connect
	function _connect()
	{
		mongo_db.open(function (err, db) {

			if(err)
			{
				//need reconnect
				setTimeout(_connect, CONST.RECONNECT_TIME);
			}
		});
	}

	_connect();
}

db.prototype.dbfinish = function(){
	return this.db_wait == 0;
}
//----------------------------------------------------------------------------//
//notice : "db_wait--" should be write after app cb, since cb may call db function again.


//cb param : obj arr
db.prototype.find = function(collection,exp,opt,cb){

	//A projection cannot contain both include and exclude specifications, except for the exclusion of the _id field.
	//In projections that explicitly include fields, the _id field is the only field that you can explicitly exclude.

	//default not need _id, if you need _id , use {fields : {_id : 1}}
	if(typeof opt === "function")
	{
		cb = opt;
		opt = {fields : {_id : 0}};
	}
	else
	{
		//check fidlds
		if (opt.fields) {
			if (opt.fields._id == 1) {

				//{other : 0, _id : 1} , this is not allow, so we need delete.
				//the _id field is always includes

				delete opt.fields._id;
			}
			else
			{
				opt.fields._id = 0;
			}
		}
		else
		{
			opt.fields = {_id : 0};
		}
	}
	
	var self = this;
	self.db_wait++;	

	function i_cb(arr) {
		
		try
		{
			if(cb)
			{
				cb(arr);
			}			
		}
		catch(e)
		{
			self.db_wait--;
			throw e;
		}
		
		self.db_wait--;
	}	
	
	this.db_mgr.request(i_cb,"find",collection, exp,opt);
};

//cb param : nothing 
db.prototype.insert = function(collection,exp,cb){

	var self = this;
	self.db_wait++;
	
	var need_id = false;
	function i_cb(result) {
	  
		//need delele the _id
		if(!need_id){
			delete exp._id;
		}
		
		try
		{
			if(cb)
			{
				cb();
			}		
		}
		catch(e)
		{
			self.db_wait--;
			throw e;
		}
		
		self.db_wait--;
	}

	//insert need change to upsert when db reconnect, because the item is already insert but result is not recv for net err.
	//we create a ObjectID manual,use id for upsert.

	//objectID create by in objectid.js:
	//var unixTime = parseInt(Date.now()/1000,10);
	//var time4Bytes = BinaryParser.encodeInt(unixTime, 32, true, true);
	//var machine3Bytes = BinaryParser.encodeInt(MACHINE_ID, 24, false);
	//var pid2Bytes = BinaryParser.fromShort(typeof process === 'undefined' ? Math.floor(Math.random() * 100000) : process.pid);
	//var index3Bytes = BinaryParser.encodeInt(this.get_inc(), 24, false, true);
	if (exp._id === undefined) {
		exp._id = new mongo.ObjectID(); 
	}
	else
	{
		need_id = true;
	}

	this.db_mgr.request(i_cb,"insert",collection, exp);
};

//cb param : total update num
db.prototype.update = function(collection,exp,newexp,cb){

	var self = this;
	self.db_wait++;
	
	var _id = null;
	function i_cb(num,result) {
		
		//restore the _id
		if(_id !== null){
			newexp.$set._id = _id;
		}

		try
		{
			if(cb)
			{
				cb(num);
			}	
		}
		catch(e)
		{
			self.db_wait--;
			throw e;
		}
		
		self.db_wait--;
	}

	if(newexp.$set !== undefined && newexp.$set._id !== undefined)
	{
		//store the _id
		_id = newexp.$set._id;

		//update should not modify _id.
		delete newexp.$set._id;
	}

	this.db_mgr.request(i_cb,"update",collection, exp,newexp,{});
};

//cb param : total update num
db.prototype.updateAll = function(collection,exp,newexp,cb){

	var self = this;
	self.db_wait++;
	
	var _id = null;
	function i_cb(num,result) {

		//restore the _id
		if(_id !== null){
			newexp.$set._id = _id;
		}

		try
		{
			if(cb)
			{
				cb(num);
			}	
		}
		catch(e)
		{
			self.db_wait--;
			throw e;
		}
		
		self.db_wait--;
	}

	if(newexp.$set !== undefined && newexp.$set._id !== undefined)
	{
		//store the _id
		_id = newexp.$set._id;

		//update should not modify _id.
		delete newexp.$set._id;
	}

	this.db_mgr.request(i_cb,"update",collection, exp,newexp,{multi:true});
};

//update if exist, insert if not exist
//cb param : isInsert(bool) ---  true : insert , false : update
db.prototype.upsert = function(collection,exp,newexp,cb){

	var self = this;
	self.db_wait++;
	
	var _id = null;
	function i_cb(num,result) {

		//restore the _id
		if(_id !== null){
			newexp.$set._id = _id;
		}

		try
		{
			if(cb)
			{
				cb(result ? (result.updatedExisting === false) : false);
			}	
		}
		catch(e)
		{
			self.db_wait--;
			throw e;
		}
		
		self.db_wait--;		
	}

	if(newexp.$set !== undefined && newexp.$set._id !== undefined)
	{
		//store the _id
		_id = newexp.$set._id;

		//update should not modify _id.
		delete newexp.$set._id;
	}

	this.db_mgr.request(i_cb,"update",collection, exp,newexp,{upsert:true});
};

//cb param : total remove num
db.prototype.remove = function(collection,exp,cb){

	var self = this;
	self.db_wait++;
	
	function i_cb(num) {
	  
		try
		{
			if(cb)
			{
				cb(num);
			}
		}
		catch(e)
		{
			self.db_wait--;
			throw e;
		}
		
		self.db_wait--;	
	}	
	
	this.db_mgr.request(i_cb,"remove",collection, exp);
};

//cb param : total doc num
db.prototype.count = function(collection,exp,cb){
	
	var self = this;
	self.db_wait++;	

	if(typeof exp === "function"){
		cb = exp;
		exp = {};      
	}

	function i_cb(num) {
	  
		try
		{
			if(cb)
			{
				cb(num);
			}
		}
		catch(e)
		{
			self.db_wait--;
			throw e;
		}
		
		self.db_wait--;	
	}		
	
	this.db_mgr.request(i_cb,"count",collection, exp);
};

//cb param : nothing
db.prototype.ensureIndex = function(collection,exp,cb){
	
	var self = this;
	self.db_wait++;	

	function i_cb() {
	  
		try
		{
			if(cb)
			{
				cb();
			}
		}
		catch(e)
		{
			self.db_wait--;
			throw e;
		}
		
		self.db_wait--;	
	}		
	
	this.db_mgr.request(i_cb,"ensureIndex",collection, exp);
};

//cb param : true or false
db.prototype.exist = function(collection,cb){
	
	var self = this;
	self.db_wait++;	
	
	function i_cb(arr) {
		try
		{
			if(cb)
			{
				cb(arr.indexOf(self.name + "." + collection) >= 0);
			}
		}
		catch(e)
		{
			self.db_wait--;
			throw e;
		}
		
		self.db_wait--;
	}

	this.db_mgr.request(i_cb,"exist",collection);
};

//cb param : nothing
db.prototype.drop = function(collection,cb){

	var self = this;
	self.db_wait++;
	
	function i_cb() {
	  
		try
		{
			if(cb)
			{
				cb();
			}
		}
		catch(e)
		{
			self.db_wait--;
			throw e;
		}
		
		self.db_wait--;
	}	
	
	this.db_mgr.request(i_cb,"drop",collection);
};

//cb param : distinct key array
db.prototype.distinct = function(collection,key,exp,cb){

	var self = this;
	self.db_wait++;
	
	if(typeof exp === "function"){
		cb = exp;
		exp = {};      
	}

	function i_cb(arr) {
	  
		try
		{
			if(cb)
			{
				cb(arr);
			}
		}
		catch(e)
		{
			self.db_wait--;
			throw e;
		}
		
		self.db_wait--;	
	}		
	
	this.db_mgr.request(i_cb,"distinct",collection, key,exp);
};

//cb param: if use inline , then ret is result arr,  otherwise ret is empty
//notice : use inline, may have 16MB result size limit
db.prototype.mapReduce = function(collection,map,reduce,options,cb){

	var inline = true;

	if(typeof options === "function"){
		cb = options;
		options = {out : {inline : 1}};      
	}
	else
	{
		if(typeof options === "string")
		{
			options = {out : {replace : options}};   
			inline = false;
		}
		else
		{
			//check have out
			if(options.out)
			{
				if(!options.out.inline)
				{
					inline = false;
				}
			}
			else
			{
				options.out = {inline : 1};
			}
		}
	}

	var self = this;
	self.db_wait++;
	
	function i_cb(result) {
		try
		{
			if(cb)
			{
				if(inline)
				{
					cb(result);
				}
				else
				{
					cb();
				}
			}
		}
		catch(e)
		{
			self.db_wait--;
			throw e;
		}
		
		self.db_wait--;			
	}

	this.db_mgr.request(i_cb,"mapReduce",collection, map,reduce,options);
};

module.exports = db;
