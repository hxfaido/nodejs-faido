

var CONST = require("../utils/const").LOG;
var _fline = require("../utils/fn").fline;

//notice that:
//in debug mode, we will not limit the log arr and object's size
//in production mode, we will limit the size to const_v.LOG.MAX_KEY_LEN


module.exports = new log_manager();

var debug_mode;
//hook console, when global log init.
var once = false;
function hook_console(self){
   
   if(!once){
      
      once = true;
      
      if(self.debug){
         console.log = self.log.bind(self);
      }
      else
      {
         var _log = new log_manager();
         _log.init(1);
         
         console.log = _log.log.bind(_log);
      } 
   }
}


//log manager
function log_manager(){
   
}

log_manager.prototype.init = function(debug, conf){

   this.debug = debug === undefined ? false : !!debug;
   
   //set debug mode in first time
   if(debug_mode === undefined){
      debug_mode = this.debug;
   }
   
   if (!conf) {
      this.conf = {
         time : CONST.DEFAULT_TIME,
         size : CONST.DEFAULT_SIZE,
         fline : CONST.DEFAULT_FLINE
      };
   }
   else
   {
      this.conf = conf;
      this.conf.time = this.conf.time || CONST.DEFAULT_TIME;
      this.conf.size = this.conf.size || CONST.DEFAULT_SIZE;
      this.conf.fline = this.conf.fline || CONST.DEFAULT_FLINE;
   }

   this.logs = {}; 
   
   this.log_class = this.debug ? require("./log_console") : require("./log_file");
   
   //lazy init once
   if(CONST.HOOK_CONSOLE)
   {
      hook_console(this);
   }
};

log_manager.prototype.log = function(type){
   
   var category = type;
   //to avoid log recursion
   try
   {
      //get timestamp first
      var time = _timestamp();
      
      var slice_i = 1;
      
      //use the default , when not have type.
      if (arguments.length < 2 || type.match(/%j/)) {
         
         category = CONST.DEFAULT_LOG;
         
         slice_i = 0;
      }
      
      //get log instance
      var obj = this.logs[category];
      
      //create log instance   
      if (!obj) {
         obj = new this.log_class(category,this.conf);
         this.logs[category] = obj;
      }
      
      var str = this.filter.apply(this, Array.prototype.slice.call(arguments,slice_i));
      
      obj.write(time,str);     
   }
   catch(e)
   {
      console.log("log " + category + " internal err : " + e);
   }
};


log_manager.prototype.filter = function(msg){
   
   var str;
   
   //we support format like this :
   // ("%j test %j", {} , []) 
   if (arguments.length > 1 && typeof msg === "string") {
      
      var len = arguments.length;
      var index = 1;                         //from index 1
      var t_args = arguments;                //arguments will change in replace callback
         
      str = msg.replace(/%[j%]/g, function(x) {
         if (x === "%%") return "%";
         if (index >= len) return x;
         
         return _tojson(t_args[index++]);
      });   
   }
   else
   {
      str = _tojson(msg);
   }
   
   
   //check fline
   if (this.conf.fline) {
      
      //0 is the fline function, 1 is the filter function, 2 is the log function, 3 is the function call log, which is we need.
      var prefix = _fline(3);
      
      str = prefix + str;
   }

   return str;
};


//----  for internal use  ----//


// get timestamp
function _formattime(t){
   return t < 10 ? "0" + t : "" + t;
}

function _timestamp(){
   
   var t = new Date();
   
   //such as "[2014-01-25 08:13:01] "  
   
   var str = "[" + t.getFullYear() + "-" + _formattime(t.getMonth()+1) + "-" + _formattime(t.getDate()) + " ";
   str += _formattime(t.getHours()) + ":" + _formattime(t.getMinutes()) + ":" + _formattime(t.getSeconds()) + "] ";
   
   return str;
}

// our internal tojson , and support circular struct
function _tojson(obj){
   
   //check debug
   if (!debug_mode) {
      
      //check the array length, avoid cost much time.
      if (obj instanceof Array && obj.length > CONST.MAX_KEY_LEN) {         
         return "array length is too long!";
      }
   }
   
   //we need the error call stack
   if(obj instanceof Error)
   {
      obj = obj.stack;
   }  
   
   if (typeof obj === "string") {
      return obj;
   }
   else if (typeof obj === "function") {
      return "[ Function ]";
   }
   else if (typeof obj === "number") {
      return ""+obj;
   }
   else if (typeof obj === "boolean") {
      return obj ? "true" : "false";
   }
   else
   {
      if (obj === null) {
         return "null";
      }
      
      if (obj === undefined) {
         return "undefined";
      }
      
      if (obj instanceof RegExp) {
         return obj.toString();
      }
   }
   
   try
   {
      //cache handle obj - avoid circular object
      var cache = [];
      var last = null;
      var len = 0;
      
      return JSON.stringify(obj,function(key,value){
        
         //check debug
         if (!debug_mode) {
            len++;
            if (len > CONST.MAX_KEY_LEN) {
               throw new Error("object is too big!");
            }
         }
        
         //"this" mean the current handle object
         if(last !== this) 
         {
            if(cache.indexOf(this) > -1)
            {
               cache.pop();	
            }  
            else
            {
               cache.push(this);
            }
            last = this;
         }
         
         if(value && typeof value === "object")
         {
            var index = cache.indexOf(value);
            if(index > -1)
               return "[ Circular " + index + " ]";
         }
        
         return value;
      });
   }
   catch(e)
   {
      return e.toString();  
   }
}

