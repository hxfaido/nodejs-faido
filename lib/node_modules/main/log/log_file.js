
//do not call write too frequently (if the server is in high load)
//because node.js use threadpool to do fs request, and use socket to sync callback,
//too frequently will cause epoll_wait week often,and much more content switch time

var CONST = require("../utils/const").LOG;

//init interval once.
var objs = [];

var once = false;
function init(obj) {
    
    objs.push(obj);
    
    if (once) {
        return;
    }
    
    once = true;
    
    setInterval(function(){
        
        //flush all caches
        for(var i = 0; i < objs.length; i++)
        {
            objs[i]._write();
        }
    },CONST.FILE_FLUSHTIME);
}


function log_file(category,conf) {
    
    this.fstream = new fstream(category,conf.size,conf.time);
    
    //may be future we can use str array to cache log, when node.js support the writev syscall.
    this.cache = "";
    
    init(this);
}

log_file.prototype.write = function(timestamp,str){
    
    this.cache += timestamp;
    this.cache += str;
    this.cache += "\n";
};

log_file.prototype._write = function(){

    //check cache is empty
    if(this.cache.length > 0){
        this.fstream.write(this.cache);
        
        this.cache = "";
    }
};

module.exports = log_file;



//----  for internal use  ----//
var log_path = "./log/";

var fs = require("fs");
var path = require("path");
var cron = require("../utils/cron");

function fstream(name,size,time) {
    
    this.filename = name;
    this.maxsize = size;
    this.time = new cron(time);
    
    var err = this.time.geterr();
    //err will cause getnext return -1
    if (err) {
        //log to console 
        console.log(err);
    }
    
    this.buf = [];
    this.has_err = false;
    
    //create file first
    var now = new Date();
    
    this.stream = null;
    
    this.cursize = 0;
    this.nexttime = this.time.getnext(now.getTime());
    
    this.create(now);
}

fstream.prototype.write = function(str){
  
    //if we meet err, ignore all str.
    if (this.has_err) {
        return;
    }
  
    //check size and time  
    this.check(str.length);
    
    if (this.stream === null) {
        this.buf.push(str);
    }
    else
    {
        this.stream.write(str);
    }
};

fstream.prototype.check = function(len){
    
    //not check when stream is not create
    if (this.stream === null) {
        
        //just add len
        this.cursize += len;
        
        return;
    }
    
    var now = new Date();
    var now_t = now.getTime();    
    
    //check size and time
    if ((this.maxsize != -1 && this.cursize >= this.maxsize) || (this.nexttime != -1 && now_t >= this.nexttime)) {
        
        //close fd
        this.stream.end();
        this.stream = null;
        
        //reset len and time 
        this.cursize = len;
        this.nexttime = this.time.getnext(now_t);
        
        //create new stream
        this.create(now);
    }
    else
    {
        //just add len
        this.cursize += len;   
    }
};


fstream.prototype.create = function(time){
    
    var self = this;
    
    //such as "./log/2012-10"    
    var path = log_path + time.getFullYear() + "-" + (time.getMonth()+1);

    //such as "./log/2012-10/log-1-16:00"
    var file = path + "/" + self.filename + "-" + time.getDate() + "-" + time.getHours() + ":" + time.getMinutes();
    
    //mode 0755
    mkdirp(path,493,function(err){
       
        if(err)
        {
            self.has_err = true;
            
            //clear buf
            self.buf = [];
            
            //log to console
            console.log("create path " + path + " failed : " + err);
        }
        else
        {
            //if the file is already exist , just append.
            self.stream = fs.createWriteStream(file, {flags : 'a'});
            
            self.stream.on("error",function(err){
                
                self.has_err = true;
                
                //clear buf
                self.buf = [];
                
                //log to console
                console.log("write file " + file + " failed : " + err);
            });
            
            self.stream.on("open",function(){
                
                var buf = self.buf;
                
                //just flush all,since the buf length is always short, file create will finish quickly
                for(var i = 0; i < buf.length; i++)
                {
                    self.stream.write(buf[i]);
                }
                
                self.buf = [];
            });
        }
    });
};

//mkdirp
function mkdirp(file,mode,cb) {
    
    fs.mkdir(file, mode, function(err){
        
        //check err
        if (!err) {
            cb();
        }
        else
        {
            //already exist
            if (err.code == "EEXIST") {
                cb();
            }
            else if (err.code == "ENOENT") {
                mkdirp(path.dirname(file),mode,function(err){
                    if (err) {
                        cb(err);
                    }
                    else
                    {
                        //call again
                        mkdirp(file,mode,cb);
                    }
                });
            }
            else
            {
                cb(err.code);
            }
        }
    });
}


