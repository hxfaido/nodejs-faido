//ensure db request send ok (when db reconnect , send all no ack requests )

var list = require("../utils/list");
var CONST = require("../utils/const");
var log_manager = require("../log/log");
_log = log_manager.log.bind(log_manager,CONST.LOG.DB_LOG);
_err = log_manager.log.bind(log_manager,CONST.LOG.ERR_LOG); 

function db_sure(id,sure) {
   
   this.id = id;
   
   this.sure = sure;
   
   if(this.sure)
   {
      //create list
      this.acklist = new list();
      
      this.req_class = dbsure_req;
   }
   else
   {
      this.req_class = db_req;
   }
}

db_sure.prototype.init = function(mongo_db){

   this.db = mongo_db;
   
   //catch "reconnect" event when in ensure mode
   if(this.sure)
   {
      var self = this;
      mongo_db.on("reconnect",function(){
         
         //store the old first, since the send will change it
         var l = self.acklist;
         
         var send_arr = [];
         for(var req = l.front(); req !== null; req = l.next(req))
         {
            send_arr.push(req);
         }
         
         //reset
         self.acklist = new list();
         
         //send all        
         for(var i = 0; i < send_arr.length; i++)
         {
            self.send(send_arr[i]);
         }
         
         _log(self.id + " send all no ack requests ok : " + i);
      });
   }  
};

db_sure.prototype.send = function(req){
   
   //db is always connected.
   req.send(this.db);
};

db_sure.prototype.create = function(cb,fn,collection){
   
   //get fn args
   var args = Array.prototype.slice.call(arguments,3);
   
   return new this.req_class(cb,fn,collection,args,this);
};



module.exports = db_sure;



//----------------------  internal db request ---------------------------//
function db_req(cb,fn,collection,args,sure) {

   this.cb = cb;
   this.fn = fn; 
   this.collection = collection;
   
   
   this.cb = cb;
  
   //store orig args for log
   this.orig_fn = fn;
   this.orig_args = args;
   
   this.args = this.orig_args.concat(this.callback.bind(this));
   
   this.sure = sure;
}

db_req.prototype.send = function(db){
   
   var self = this;
   
   //exist need handle specially
   if(self.fn === "exist")
   {
		db.collectionNames(self.collection,{namesOnly:"true"},function(err,arr){
			self.callback(err,arr);
		});	   
   }
   else
   {
	   db.collection(self.collection,function(err,coll){
		  
		  if(err)
		  { 
			 self.callback(err);
		  }
		  else
		  {         
			 coll[self.fn].apply(coll,self.args);
		  }
	   }); 	   
   }
};

//our wrapper callback
db_req.prototype.callback = function(err, result){
   
   //find need handle specially
   if (!err && this.fn === "find") {
      
      //use cursor to get all docments
      var cursor = result;
      cursor.toArray(this.inter_callback.bind(this)); 
   }
   else
   {
      this.inter_callback.apply(this,arguments);
   }
};

//callback
db_req.prototype.inter_callback = function(err){
   
   if (err) {
    
      //log the err, we will not invoke upper app callback
      this.log_err(err);
   }
   else
   {     
      //we need catch app level err, to avoid internal error
      try
      {
         //remove the err
         if(typeof this.cb === "function")
         {
            this.cb.apply(null,Array.prototype.slice.call(arguments,1));
         }
      }
      catch(e)
      {
         _err(e);
      }          
   }
};

db_req.prototype.log_err = function(err){

   //format str - use orig
   var str = this.sure.id + " " + this.orig_fn + " failed : " + err + " ! params is -> ";
   for(var i = 0; i < this.orig_args.length; i++)
   {
      str += "%j , ";
   }
   
   var args = [].concat(str,this.orig_args);
   
   //log to the err file
   _err.apply(null,args);   

};

//----------------------  internal db sure request ---------------------------//
var util = require("util");

function dbsure_req() {
   
   db_req.apply(this,arguments);
   
   //changed flag
   this.changed = false;
}

util.inherits(dbsure_req, db_req);

dbsure_req.prototype.send = function(db){
   
   //add to list
   this.sure.acklist.push_back(this);
   
   db_req.prototype.send.call(this,db);
};

dbsure_req.prototype.inter_callback = function(err){
   
   //check is network err  -- need use the internal _serverState, maybe invole handler first before connectionPool stop
   if (err && this.sure.db.serverConfig._serverState === "disconnected") {
      
      //change some method to ensure resend is correct
    
      if (this.fn === "insert") {
        //insert need change to upsert when reconnect.
        
        this.fn = "update";
        
        //insert param is : exp,cb
        //upsert param is : exp,newexp,{upsert:true},cb
        
        var exp = this.args[0];
        //always have the _id , we wrapper in db method.
        var exp_id = exp._id;                                               
        //when upsert, we should delete the _id, since Mod on _id not allowed 
        delete exp._id;
        
        this.args = [{_id : exp_id}, {$set : exp}, {upsert:true}, this.callback.bind(this)];
        
        this.changed = true;
      }
      
      //log with err
      this.log_err(err);
      
      _err(this.sure.id + " network err, we will send request again when reconnected.");
      
      //check is upsert,to show the warning.
      if (this.orig_fn === "update") {
         
         //upsert param is : exp,newexp,{upsert:true},cb
         
         //get the options    
         var op = this.args[this.args.length - 2];       //always have the option , we wrapper in db method.
         if (op && op.upsert) {
            
            //when reconnect, use upsert we can not know is update or insert, because the item maybe insert but result is not recv for net err,
            //so will cause insert become to update.
            
            _err(this.sure.id + " warning! we can not guarantee the callback result correct when reconnect to send upsert request.");
         }
      }
      
      //not invoke callback.
   }
   else
   {
      //remove from list
      this.sure.acklist.remove(this);
      
      //add _id again, when insert to upsert, the app level may need it
      if(this.changed)
      {
         var new_exp = this.args[0];
         var ori_exp = this.orig_args[0];
         
         ori_exp._id = new_exp._id;
      }
      
      db_req.prototype.inter_callback.apply(this,arguments);     
   }
};


